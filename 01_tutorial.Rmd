---
title: "Growing Shade methods"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  github_document:
    toc: true
always_allow_html: true
urlcolor: blue
---

# Introduction

Growing Shade is a prioritization tool for tree canopy enhancement and preservation. Growing Shade was conceptualized by the Metropolitan Council, Tree Trust, and The Nature Conservancy with a focus on the Twin Cities (Minnesota) area. All analyses and code were developed by Ellen Esch. The Twin Cities version of Growing Shade can  be accessed at: www.growingshade.com or https://metrotransitmn.shinyapps.io/growing-shade/. 

The components of Growing Shade relevant to population demographics (i.e., determining environmental justice priority areas) can be scaled to any area within the United States. The components relevant to the tree canopy have been parameterized to the Twin Cities region, but should work pretty well in other temperate areas with deciduous and coniferous trees.

This tutorial walks through how to grab and synthesize various data pieces which go into making Growing Shade. This document should be useful when doing data updates update, or trying to scale this workflow to other regions/areas.

The first time you run this code, it will be helpful to walk step-by-step through the various pieces. There are several places where you'll get instructions to request and save API keys, or other manual steps which can't be automated. However, after you walk thorough it initially, in future runs (if needed) or for small data/geography adjustments, you can probably be successful running everything in one go!

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message = F, warning = F,
                      cache = F)
library(dplyr); library(tidyr); library(readr); library(stringr); library(tibble); library(ggplot2)
library(tigris)
library(sf)
library(tidycensus)
library(ggbeeswarm)
library(RSocrata)
library(here)


st_erase = function(x, y) st_difference(x, st_union(st_combine(y)))
`%not_in%` <- Negate(`%in%`)
```

# Set parameters

These global parameters dictate what state/county combinations will be used, as well as from what year various data pieces come from. Since the data pieces are updated on different schedules, it's unfortunately not as simple as setting a "global" rule to use data corresponding to the current year

This code is set up to use/process 2020-era census geographies at the block group level (even though some data sources are still using 2010-era geographies...but we'll deal with those later).

```{r set-parameters}
#####
# Geography variables
####
state <- c("MN")
county <- c("Anoka", "Carver", "Dakota", "Hennepin", "Ramsey", "Scott", "Washington") # either type in specific county names, or for all counties within a state assign `county <- NULL`

process_geographies <- TRUE 

#######
# Demographic variables
######
acs_year <- 2020 #The 2017-2021 ACS 5-year estimates are scheduled to be released on December 8, 2022. So this can be updated with "2021" then. 
census_year <- 2020

process_demographics <- FALSE

```

# Process demographic data

The demographic information is fetched using the APIs/app tokens. Follow these instructions:

You will need an API key from Census:

-   [Request an api key](https://api.census.gov/data/key_signup.html)
-   Enter in the console: `usethis::edit_r_environ()`
-   When the `.Renviron` file comes up in the editor, type: `CENSUS_KEY="KEY GOES HERE, INSIDE QUOTES"`
-   Save and close the `.Renviron` file.
-   Restart R.

You will need an app token from CDC:

-   [Request an app token](https://chronicdata.cdc.gov/profile/edit/developer_settings)
-   You may have to create an account with Tyler Data & Insights ID
    -   More information about "app tokens" and metadata are on the [PLACES data overview](https://dev.socrata.com/foundry/chronicdata.cdc.gov/cwsq-ngmh)
    -   Note that CDC has APIs and app tokens. It's a bit confusing, but be sure you are looking at the app token for this.
-   Enter in the console: `usethis::edit_r_environ()`
-   When the `.Renviron` file comes up in the editor, type: - `CDC_KEY="APP TOKEN GOES HERE, INSIDE QUOTES"` - `CDC_EMAIL="email you signed up with goes here, inside quotes"`
-   `CDC_PASSWORD="password you used to signup with goes here, inside quotes"`
-   Save and close the `.Renviron` file.
-   Restart R.

## Decennial census

Race variables come from the decennial 2020 census. Currently, the decennial census data is preferred over ACS data because it is a population count rather than a sample and because ACS data uses the average of 5 years (so starting with the ACS 2021-2025 data, it may be logical to switch over to using the ACS data instead).

```{r decennial}
if (process_demographics == TRUE) {
census_api_key(Sys.getenv("CENSUS_KEY"))

  race_var <- c(
    "P2_005N", # white nh
    "P2_006N", # black nh
    "P2_007N", # amin nh
    "P2_008N", # asian nh
    "P2_009N", # hawaiian pi nh
    "P2_010N", # some other nh
    "P2_011N", # 2+ nh
    "P2_002N" # hispanic
  )

  decennial_data <- get_decennial(
      geography = "block group",
      variables = race_var, 
      summary_var = "P1_001N",
      year = census_year,
      state = state,
      county = county,
      geometry = F
    ) %>%
      pivot_wider(names_from = variable, values_from = value) %>%
    
    mutate(across(starts_with("P2"), ~ .x / summary_value)) %>%
    rename(whitenh = P2_005N,
        pblacknh = P2_006N,
        pamindnh = P2_007N,
        phisppop = P2_002N) %>%
    mutate(pothmultnh = (P2_010N + P2_011N),
           pasiannh = (P2_008N + P2_009N),
           pbipoc = 1 - whitenh) %>%
    select(-c(starts_with("P2"), summary_value, NAME))
  
  save(file = paste0(here::here(), "/data-raw/decennial_data.rda"), decennial_data)
} else {
  load(paste0(here::here(), "/data-raw/decennial_data.rda"))
}
```

## American Community Survey

Other demographic variables come from the American Community Survey 5-year data. ACS numbers come from a surveyed population sample.

Check what is the most [recent year of ACS data here](https://api.census.gov/data.html). Search for "acs5" and see what is the most recent year of data available.

```{r acs}
if (process_demographics == TRUE) {
  census_api_key(Sys.getenv("CENSUS_KEY"))

  v20 <- load_variables(acs_year, "acs5", cache = TRUE)
  View(v20 %>% filter(geography == "block group"))
  #  you may need to access the table shells: https://www.census.gov/programs-surveys/acs/technical-documentation/table-shells.html
  #  census reporter topics are also very useful! https://censusreporter.org/topics/

  acs_variables <- c(
    "B01001_001", #poptotal
    paste0("B01001_00", c(3:6)), #under18 m
    paste0("B01001_0", c(27:30)), #under18 f
    paste0("B01001_0", c(20:25, 44:49)), #over 65m, f
    "B19013_001",# median hh income
    "B25003_001", #tenure_total
    "B25003_002", #tenure owners
    "B23025_001", #employment status denominator
    "B23025_007", #unemployed
    paste0("C17002_00", c(1:6)) #poverty status
    )
  
 acs_data <-  get_acs(
    geography = "block group",
    variables = acs_variables,
    survey = "acs5",
      state = state,
      county = county,
    year = acs_year
  ) %>%
   select(-moe, -NAME) %>%
   pivot_wider(names_from = variable, values_from = estimate)  %>%
   
   #process to useable forms of the data
   mutate(
     under18 = rowSums(across(c(
       paste0("B01001_00", c(3:6)), #under18 m
       paste0("B01001_0", c(27:30)) #under18 f
       ), na.rm = T)),
     over65 = rowSums(across(c(
       paste0("B01001_0", c(20:25, 44:49)) #over 65m, f
     ), na.rm = T))) %>%
   mutate(across(c(under18, over65), ~.x / B01001_001),  #, .names = "{.col}_percent"),
          sensage = under18 + over65,
          pownhome = B25003_002 / B25003_001,
          pwk_nowork = B23025_007 / B23025_001,
          ppov185 = (C17002_002 + C17002_003 + C17002_004 + C17002_005 + C17002_006) / C17002_001) %>%
   rename(hhincome = B19013_001) %>%
   select(c(GEOID, !starts_with(c("B", "C"))))
 
  save(file = paste0(here::here(), "/data-raw/acs_data.rda"), acs_data)
} else {
  load(paste0(here::here(), "/data-raw/acs_data.rda"))
}
 
```

## PLACES health data

Health metrics come from [PLACES: Local Data for Better Health, Census Tract Data](https://chronicdata.cdc.gov/500-Cities-Places/PLACES-Local-Data-for-Better-Health-Census-Tract-D/cwsq-ngmh). I am not aware that there is a way to use a "health_year" parameter to get a specific timestamp of the data, so please just double check that the most recent data is being used! CDC has indicated that they *might* soon be switching over to using 2020-vintage census geographies rather than the old 2010 geographies, so the processing will get simplified at that point.

Also, because this CDC data currently uses old census geographies, you will need to download a crosswalk - Download the state-specific crosswalk of ["Block Groups --\> Census Tracts" for year "2010 --\> 2020" from NHGIS](https://www.nhgis.org/geographic-crosswalks#download-from-block-groups) - Place the resultant file in the data-raw folder

```{r health}
##########
# CDC health data
#########
# variable options are documented here: https://www.cdc.gov/places/measure-definitions/index.html

if (process_demographics == TRUE) {

raw_health <- read.socrata(
  # "https://chronicdata.cdc.gov/resource/cwsq-ngmh.json?$where=stateabbr in('MN', 'WI')",
 paste0("https://chronicdata.cdc.gov/resource/cwsq-ngmh.json?$where=stateabbr in('", state, "')"),
  app_token = Sys.getenv("CDC_KEY"), 
  email     = Sys.getenv("CDC_EMAIL"), 
  password  = Sys.getenv("CDC_PASSWORD")) %>%

  #get the columns of interest. there are more variables as an fyi though!
# names(bg_health)
# levels(as.factor(bg_health$measure))
  filter(measure %in% c("Current asthma among adults aged >=18 years",
                        "Chronic obstructive pulmonary disease among adults aged >=18 years",
                        "Mental health not good for >=14 days among adults aged >=18 years",
                        "Physical health not good for >=14 days among adults aged >=18 years")) %>%
  dplyr::select(locationname, measureid, data_value) %>%
  mutate(data_value = as.numeric(data_value) / 100) %>% #change to fraction
  pivot_wider(names_from = measureid, values_from = data_value)

fips <- tigris::lookup_code(state = state) %>%
  stringr::str_split("'", simplify = T)

crosswalk <- read_csv(paste0(here::here(), "/data-raw/nhgis_bg2020_tr2010_", fips[,2], ".csv"),
                      col_types = c('tr2010ge' = 'c',
                                    "bg2020ge" = "c")) %>%
  select(tr2010ge,#census geoid for 2010
         bg2020ge,#census geoid for 2020
         wt_pop) %>% #use weighted population crosswalk
  group_by(bg2020ge) %>%
  slice(which.max(wt_pop)) %>% # just get the crosswalk for where most people live. it's oversimplified, but pretty decent esp since block groups generally nest nicely into tracts across census geographies
  select(-wt_pop)


## translate health data into 2020 geographies
health_data <- raw_health %>%
  full_join(crosswalk, by = c("locationname" = "tr2010ge"))

  save(file = paste0(here::here(), "/data-raw/health_data.rda"), health_data)
} else {
  load(paste0(here::here(), "/data-raw/health_data.rda"))
}

```

# Process geographies

Growing Shade is set up to have data at the block group, neighborhood, and city/township (ctu) levels.

### Census block groups

Getting these geography files is easy - just downloaded directly.

```{r census-geography}
bg_geo <- block_groups(state = state, 
                                    county = county,
                                    year = census_year) 

# sf::st_write(bg_geo, "/Users/escheh/Documents/GitHub/planting.shade/storymap-info/shapefiles/bg_geo.shp", append = FALSE)

```


### Neighborhoods and city levels

Since we're going to be making a map which shows census tracts, cities, or neighborhoods depending on the user input, a crosswalk needs to be made which relates block groups to the city and neighborhood levels.

This section doesn't seem to be easily scalable to other regions. As such, the code for this section will likely need to be customized, and processing will be done within the `02_geographies.Rmd` script. Further, if this section doesn't apply for other regions, it should be easy enough to remove elements in the user-interface of the application.


In any case, the following files should exist in the `data` folder (again, the `02_geographies.Rmd` script shows an example of creating these files for the Twin Cities region).

- **ctu_crosswalk** which assign every block group in the region into a core city. Column names should be as follows:
  - `GEO_NAME` (city name, e.g. "Minneapolis" or "Stillwater")
  - `bg_id` (block group id)
- **nhood_crosswalk** which assigns block group in the region into a neighborhood. Column names should be as follows:
  - `GEO_NAME` (neighborhood name, e.g. "Powderhorn" or "Downtown")
  - `city` (core city in which neighborhood lies, e.g. "Minneapolis")
  - `bg_id` (block group id)
- **wide_ctu_crosswalk**


```{r, child = c('02_geographies.Rmd'), include=F, eval=F}
```


# Remote sensing data

This section *may* scale to other regions, but currently requires some initial processing steps done *outside* of R, and hence the code has been moved into the `02_remotesensing.Rmd` script. 

These are the resulting files which should exist:

**still working on this**

- tree canopy
- NDVI


# Environmental data


## Lifetime cancer risk from air toxins

The EPA's 2021 EJSCREEN data release can be downloaded automatically and filtered for the region of interest. Interestingly, the 2021 EJSCREEN data uses 2017 AirToxScreen data, even though there does appear to be a more recent, [2018 AirToxScreen file](https://www.epa.gov/AirToxScreen/2018-airtoxscreen-assessment-results) as of October 3, 2022. 

It is my recommendation to use the EJSCREEN data because the process can be automated, and then just [check back to see when this data gets updated for future years](https://gaftp.epa.gov/EJSCREEN). Hopefully the 2018 AirToxScreen data will be incorporated soon. 

Additionally, please note that the 2021 EJSCREEN data is using old (2010-vintage) Census geographies (at the tract level). Fortunately, the crosswalk downloaded to process the PLACES health data will additionally work here. 


```{r air-toxins}
if (process_demographics == TRUE) {

temp <- tempfile()
temp2 <- tempfile()
download.file(
  "https://gaftp.epa.gov/EJSCREEN/2021/EJSCREEN_2021_USPR_Tracts.csv.zip",
  destfile = temp
)
unzip(zipfile = temp, exdir = temp2)
list.files(temp2)

ejscreen <- read_csv(paste0(temp2, pattern = "/EJSCREEN_2021_USPR_Tracts.csv"),
                     col_select = c(ST_ABBREV, CANCER, ID)) %>%
  filter(ST_ABBREV == state)

# #ejscreen is still using 2010 geographies
# ejscreen %>% left_join(bg_geo %>%
#                          mutate(ID = substr(GEOID, start = 1, stop = 11))) %>%
#   st_as_sf() %>%
#   ggplot() +
#   geom_sf(aes(fill = CANCER))

files <- list.files(temp2, full.names = T)
file.remove(files)

## translate into 2020 geographies
cancer_data <- ejscreen %>%
  full_join(crosswalk, by = c("ID" = "tr2010ge")) %>%
  rename(bg_id = bg2020ge)

  save(file = paste0(here::here(), "/data-raw/cancer_data.rda"), cancer_data)
} else {
  load(paste0(here::here(), "/data-raw/cancer_data.rda"))
}

```

## Climate vulnerability - temperature & flooding

This section relies on processing remote sensing data outside of R, and may require some specific processing to work for other regions. Here, the files created are as follow: 

- **env_data** Column names should be as follows:
  - `bg_id` (block group geo-identifier)
  - `avg_temp` (average land surface temperature during a heatwave)
  - `prim_flood` (amount of land susceptible to primary flooding)

```{r matt-data}
env_data <- readxl::read_xlsx(paste0(here::here(), "/data-raw/CLIMATE_BG20.xlsx")) %>%
  transmute(bg_id = BG20,
            avg_temp = AVG_TEMP,
            prim_flood = PRIM_FLOOD)

```


# Geographic overlay files

This may not be relevant for other regions, but here is the code.

## Redlining

HOLC Redlining; this data was originally in equity considerations data set, but that data uses old 2010 geographies, so need to actually get the data.

Remove open water. "all non residential"

```{r}
holc_data <- readxl::read_xlsx(paste0(here::here(), "/data-raw/HOLC_BG20.xlsx")) %>%
  transmute(bg_id = BG20,
            holc_pred = HOLC_4_RED)

```

```{r holc-geography}
## holc  ---------------
# ftp://ftp.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_metc/plan_historic_holc_appraisal/gpkg_plan_historic_holc_appraisal.zip
temp <- tempfile()
download.file("ftp://ftp.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_metc/plan_historic_holc_appraisal/gpkg_plan_historic_holc_appraisal.zip",
  destfile = temp
)

redline_raw <- sf::read_sf(unzip(temp, "plan_historic_holc_appraisal.gpkg")) %>%
  filter(HSG_SCALE == "Hazardous") %>% 
  sf::st_union() %>%
  sf::st_transform(4326)

fs::file_delete("plan_historic_holc_appraisal.gpkg")
```

# Combine all variables

Merge demographic and environmental data

```{r combinedata}
bg_growingshade_data_allMN <- 
  
  #demographics
  census_race %>%
  full_join(bg_acs) %>%
  full_join(tract_acs) %>%
  # filter(bg20 == "270531016003") %>%
  
  full_join(matt_data) %>% #equity_considerations
  full_join(bg_health3) %>%

  #environmental
  full_join(bg_canopy) %>%
  full_join(bg_ndvi) %>%
  
  #update some variables
  # filter(str_detect(bg10, "27003|27019|27037|27053|27123|27139|27163")) %>%
  mutate(tr20 = substr(bg20, 1, 11)) %>% #this is the tract id


  mutate(inverse_ndvi_uncultivated = ndvi_uncultivated,
         inverse_ndvi_land = ndvi_land,
         canopy_percent2 = canopy_percent,
         pop_density = poptot_mc / landacres,
         housing_density = hutot_mc / landacres) %>%
  rename(bg_string = bg20) %>%
  rowwise() %>%
  mutate(holc_pred = if_else(is.na(holc_pred), 0, holc_pred)) %>%
  
    # deal with some non residential blocks and insufficent data
    mutate(across(c(poptotal:pwk_nowork, pd_any, env_cancer:holc_pred, CASTHMA:PHLTH, pop_density:housing_density), ~ if_else(poptotal == 0, NA_real_, .x)),
           p_0017 = if_else(is.nan(p_0017), tr_p_0017, p_0017),
           p_65up = if_else(is.nan(p_65up), tr_p_65up, p_65up),
           sens_age = if_else(is.nan(sens_age), tr_sens_age, sens_age),
           mdhhincnow = if_else(is.na(mdhhincnow), tr_medianhhinc, mdhhincnow),
           phhi_qntl1 = if_else(is.na(phhi_qntl1), tr_phhi_qntl1, phhi_qntl1),
           pwk_nowork = if_else(is.na(pwk_nowork), tr_pwk_nowork, pwk_nowork)) %>%
  # mutate(across(c(poptotal:pwk_nowork, pd_any:holc_pred, CASTHMA:PHLTH, pop_density:housing_density), ~ if_else(poptotal < 10, NA_real_, .x)),
  #        across(c(poptotal:pwk_nowork, pd_any:holc_pred, CASTHMA:PHLTH, pop_density:housing_density), ~ if_else(is.na(mdhhincnow), NA_real_, .x))
  #        ) %>%
  # mutate(across(c(pblacknh:pbipoc, phhi_qntl1, pwk_nowork, env_cancer, mdhhincnow), ~ if_else((is.nan(.x) | is.na(.x)) & poptotal == 0, NA_real_, .x))) %>%
  dplyr::select(-c(pblacknh_acs:pbipoc_acs)) %>% 
      # get rid of blocks where acs has no data
    mutate(across(c(poptotal:pwk_nowork, pd_any, env_cancer:holc_pred, CASTHMA:PHLTH, pop_density:housing_density), ~ if_else(is.nan(sens_age) | is.na(sens_age), NA_real_, .x))) 
  # filter(!is.na(sens_age), !is.nan(sens_age)) #get rid of block groups where there is no acs data


#%>% #and for this project, I need to rename the tract variable
  # add_column(avg_temp = sample(100, size = nrow(bg_canopy), replace = TRUE),
             # env_cancer = sample(100, size = nrow(bg_canopy), replace = TRUE),
             # green_roof = sample(100, size = nrow(bg_canopy), replace = TRUE),
             # holc_pred = sample(100, size = nrow(bg_canopy), replace = TRUE),
             # luse_green = sample(100, size = nrow(bg_canopy), replace = TRUE),
             # phhi_qntl1 = sample(100, size = nrow(bg_canopy), replace = TRUE),
             # prim_flood = sample(100, size = nrow(bg_canopy), replace = TRUE),
             # pwk_nowork = sample(100, size = nrow(bg_canopy), replace = TRUE),
             # tr_ej = sample(100, size = nrow(bg_canopy), replace = TRUE)) %>%
  
bg_growingshade_data <- bg_growingshade_data_allMN %>%
  filter(str_detect(bg_string, "27003|27019|27037|27053|27123|27139|27163")) #just do metc region for now

filter(bg_growingshade_data_allMN, bg_string %in% c("270539800001")) #this has population, but no age component
filter(bg_growingshade_data_allMN, poptotal <10 )
filter(bg_growingshade_data_allMN, is.na(tr_medianhhinc))
# temp <- tempfile()
# download.file("https://resources.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_metc/society_census_acs/xlsx_society_census_acs.zip",
#   destfile = temp
# )

# # tract variables of interest; some variables only exist at tract level
# acs_bgtest <- readxl::read_xlsx(unzip(temp, "CensusACSBlockGroup.xlsx")) %>%
#   janitor::clean_names()  %>%
#   filter(geog_unit %in% c("270531263002", "270531007004"))#, "270017701001"))
#   # transmute(bg20 = geog_unit,
#   #           pd_any = anydis / cdenom,
#   #           povdenom = povdenom)
# acs_bgtest$ageunder18
# acs_bgtest$age65up
# 
# acs_bgtest %>% filter(geog_unit %in% c("270531007004")) %>% dplyr::select(geog_unit, poptotal, meanhhinc, medianhhi)#, "270531007004"))
# 
# census_race %>% filter(bg20 %in% c("270531263002"))# %>% dplyr::select(geog_unit, meanhhinc, medianhhi, poptotal)#, "270531007004"))
# acs_bgtest %>% filter(geog_unit %in% c("270531263002")) %>% dplyr::select(geog_unit, poptotal, meanhhinc, medianhhi)#, "270531007004"))
# 
# fs::file_delete("CensusACSTract.xlsx")
```

Add some metadata.

```{r make-metadata}
gs_data_codes <- read_csv(paste0(here::here(), "/data-raw/metadata.csv"))
```

Standardize and re-scale variables so we can create equally weighted priority scores. Do *not* include spatial data at this point, it should be joined after summarizing to save computational time.

```{r standardize-rescale}

bg_growingshade_main <- bg_growingshade_data %>%
  pivot_longer(names_to = "variable", values_to = "raw_value", -c(bg_string, tr20)) %>% #end the code after this line if you just want the reshaped data
  group_by(variable) %>%
  mutate(MEAN = mean(raw_value, na.rm = T),
         SD = sd(raw_value, na.rm = T),
         MIN = min(raw_value, na.rm = T),
         MAX = max(raw_value, na.rm = T),
         COUNT = as.numeric(sum(!is.na(raw_value))),
         z_score = (raw_value - MEAN)/SD) %>%
  
  full_join(gs_data_codes, by = 'variable') %>%
  
  #create nominal weights
  mutate(weights_nominal = case_when(interpret_high_value == "high_opportunity" ~ (raw_value - MIN) / (MAX - MIN) * 10,
                                     interpret_high_value == "low_opportunity" ~ 10 - (raw_value - MIN) / (MAX - MIN) * 10,
                                     TRUE ~ NA_real_)) %>%
  
  #Weights Standard Score
  mutate(weights_scaled = case_when(interpret_high_value == "high_opportunity" ~ pnorm(z_score) * 10,
                                    interpret_high_value == "low_opportunity" ~ (10 - pnorm(z_score) * 10),
                                    TRUE ~ NA_real_)) %>%
  
  #weights rank
  mutate(weights_rank = case_when(interpret_high_value == "high_opportunity" ~ min_rank(desc(weights_nominal)) / COUNT * 10,
                                  interpret_high_value == "low_opportunity" ~ min_rank(desc(weights_nominal)) / COUNT * 10,
                                  TRUE ~ NA_real_)) %>%
  
  # #rank
  mutate(overall_rank = case_when(interpret_high_value == "high_opportunity" ~ min_rank(desc(as.numeric(weights_nominal))),
                                  interpret_high_value == "low_opportunity" ~ min_rank(desc(as.numeric(weights_nominal))))) %>%
  #clean
  dplyr::select(-MEAN, -SD, -MIN, -MAX)  %>%
  full_join(wide_ctu_crosswalk %>% rename(tr20 = GEOID)) %>%
  filter(!is.na(name))

########
# save data
########
usethis::use_data(bg_growingshade_main, overwrite = TRUE)
gs_data_codes %>% arrange(type, name)%>% dplyr::select(type, name)

```

# Create independant files for export

## Regional averages

Create some regional averages. While the average values for the block groups are needed to create zscores, those averages are not the regional averages. Ex average median income of block groups might be 60,000 but the regional average might be lower if there are more people living in ares with lower income.

```{r regional-averages}
# ########
# # create metadata
# #########
md1 <- bg_growingshade_main %>% 
  group_by(variable) %>% 
  summarise(MEANRAW = mean(raw_value, na.rm = T),
            MEANSCALED = mean(weights_scaled, na.rm = T))

temp <- tempfile()
download.file("https://resources.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_metc/society_census_acs/xlsx_society_census_acs.zip",
  destfile = temp
)
acs_tr2 <- readxl::read_xlsx(unzip(temp, "CensusACSTract.xlsx")) %>%
  janitor::clean_names()

acs_metadata <-
acs_tr2 %>% #use tracts becuase it has info about disability
    filter(str_detect(geoid, "27003|27019|27037|27053|27123|27139|27163"),
           year == 2020) %>% #just do metc region for now
  dplyr::select(geoid, poptotal:pphother) %>%
  pivot_longer(names_to = "variable", values_to = "values", -geoid) %>%
  group_by(variable) %>%
  summarise(SUM = sum(values, na.rm = T)) %>%
  pivot_wider(names_from = variable, values_from = SUM) %>%
  transmute(rgn = "twin cities",
            ppov185 = (povertyn + poverty150 + pov150_185) / povdenom,
            pbipoc = (poptotal - whitenh) / poptotal,
            pamindnh = (amindnh) / poptotal,
            phisppop = hisppop / poptotal,
            pblacknh = blacknh / poptotal,
            pasiannh = (asiannh + pacificnh) / poptotal,
            pothmultnh = (othernh + multracenh) / poptotal,
            pownhome = ownerocc / hutotal,
            p_65up = age65up / poptotal,
            p_0017 = ageunder18 / poptotal,
            sens_age = (age65up + ageunder18) / poptotal,
            pd_any = anydis / cdenom) %>%
  pivot_longer(names_to = "variable", values_to = "MEANRAW2", -rgn)

md_gee <- 
  tribble(~rgn, ~variable, ~MEANRAW2,
          "twin cities", "canopy_percent", ctu_list_raw$avgcanopy[1], 
          "twin cities", "canopy_percent2", ctu_list_raw$avgcanopy[1]
  )

metadata <- bg_growingshade_main %>%
  dplyr::group_by(type, name, variable, interpret_high_value, cc, ej, ph, cons) %>%
  dplyr::count() %>%
  dplyr::ungroup() %>%
  full_join(md1) %>%
  mutate(niceinterp = 
               case_when(interpret_high_value == "high_opportunity" ~ "Higher",
                         TRUE ~ "Lower"),
         nicer_interp = case_when(niceinterp == "Lower" ~ "Lower values = higher priority", 
                                  variable == "inverse_ndvi_uncultivated" ~ "Higher values = higher priority",
                                  variable == "inverse_ndvi_land" ~ "Higher values = higher priority",
                                  variable == "canopy_percent2" ~ "Higher values = higher priority",
                                  TRUE ~ "")) %>%
  full_join(acs_metadata %>%
              bind_rows(md_gee)) %>%
  mutate(MEANRAW = if_else(!is.na(MEANRAW2), MEANRAW2, MEANRAW)) %>%
  dplyr::select(-MEANRAW2, -rgn)

usethis::use_data(metadata, overwrite = TRUE)

```

## Highest priority for each block group

For storymap and to make database.

```{r}
highest_p <- function(x) {
  test <- enquo(x)
  
   bg_growingshade_main %>%
  filter(name %in% (metadata %>%
                      filter(!!test == 1)))
}

highest_p(ph)

highest_p <- function(group_var) {
  selectedvars <- metadata %>%
    filter(!!enquo(group_var) == 1) %>%
    .[,2]
  bg_growingshade_main %>% 
    filter(name %in% selectedvars$name) %>%
      group_by(bg_string) %>%
      summarise(MEAN = mean(weights_scaled, na.rm = F)) #set to false so that public health or ej doesnt get calculated if it is a nonres area
}

priority_summary_1 <-highest_p(ph) %>% rename(`Public health` = MEAN) %>%
  full_join(highest_p(cons) %>% rename(Conservation = MEAN)) %>%
  full_join(highest_p(ej) %>% rename(`Environmental justice` = MEAN)) %>%
  full_join(highest_p(cc) %>% rename(`Climate change` = MEAN)) %>%
  pivot_longer(names_to = "preset", values_to = "score", -bg_string) 

priority_summary <- priority_summary_1 %>%
  group_by(bg_string) %>%
  summarise(score = max(score, na.rm = T)) %>%
  left_join(priority_summary_1) %>%
  rename(highest_priority = preset) %>%
  rename(GEOID = bg_string)

```

highest priority all

```{r include=F, eval = F}

highest_p_all <- function(group_var) {
  selectedvars <- metadata %>%
    filter(!!enquo(group_var) == 1) %>%
    .[,2]
  bg_growingshade_main_allMN %>% 
    filter(name %in% selectedvars$name) %>%
      group_by(bg_string) %>%
      summarise(MEAN = mean(weights_scaled, na.rm = F))
}

priority_summary_1_all <-highest_p_all(ph) %>% rename(`Public health` = MEAN) %>%
  full_join(highest_p_all(cons) %>% rename(Conservation = MEAN)) %>%
  full_join(highest_p_all(ej) %>% rename(`Environmental justice` = MEAN)) %>%
  full_join(highest_p_all(cc) %>% rename(`Climate change` = MEAN)) %>%
  pivot_longer(names_to = "preset", values_to = "score", -bg_string) 

priority_summary_all <- priority_summary_1_all %>%
  pivot_wider(names_from = preset, values_from = score) %>%
  left_join(bg_growingshade_main_allMN %>%
  rename(scaled = weights_scaled,
         raw = raw_value) %>%
  # ungroup() %>%
  dplyr::select(bg_string, variable, scaled, raw) %>%
  pivot_wider(names_from = variable, values_from = c(scaled, raw))) %>%
  arrange(bg_string) %>%
  rename(block_group_id_2010 = bg_string)



bg_geo %>%
  right_join(priority_summary_all, by = c("GEOID" = "block_group_id_2010")) %>%
  filter(!is.na(`Environmental justice`)) %>%
  ggplot() +
  geom_sf(aes(fill = `Environmental justice`), lwd = 0) +
  theme_minimal()

```

# Export data

```{r bg_shapefiles_for_mapping}

mn_bgs_raw <- bg_geo %>%
  right_join(wide_ctu_crosswalk) %>%
  full_join(bg_canopy %>% rename(GEOID = bg20)) %>%
  full_join(priority_summary) %>%
  full_join(priority_summary_1 %>%
              group_by(preset) %>% 
              # mutate(rank = rank(-score)) %>%
              # dplyr::select(-score) %>%
              pivot_wider(names_from = preset, values_from = score)#rank)
            %>% rename(GEOID = bg_string)) %>%
  mutate(avgcanopy = mean(canopy_percent, na.rm = T)) %>%
  dplyr::select(-STATEFP, -COUNTYFP, -TRACTCE, -BLKGRPCE, -NAMELSAD, -MTFCC, -FUNCSTAT, -INTPTLAT, -INTPTLON) %>%
  sf::st_as_sf() %>%
      sf::st_transform(4326) %>% 
  filter(!is.na(highest_priority)) %>% #don't want greater mn in here
    mutate(fancyname = case_when(substr(GEOID, 3, 5) == "053" ~ paste0("Hennepin County tract ", as.numeric(substr(GEOID, 6, 11))/100, ", block group ", as.numeric(substr(GEOID, 12, 12))),
                               substr(GEOID, 3, 5) == "003" ~ paste0("Anoka County tract ", as.numeric(substr(GEOID, 6, 11))/100, ", block group ", as.numeric(substr(GEOID, 12, 12))),
                               substr(GEOID, 3, 5) == "019" ~ paste0("Carver County tract ", as.numeric(substr(GEOID, 6, 11))/100, ", block group ", as.numeric(substr(GEOID, 12, 12))),
                               substr(GEOID, 3, 5) == "037" ~ paste0("Dakota County tract ", as.numeric(substr(GEOID, 6, 11))/100, ", block group ", as.numeric(substr(GEOID, 12, 12))),
                               substr(GEOID, 3, 5) == "123" ~ paste0("Ramsey County tract ", as.numeric(substr(GEOID, 6, 11))/100, ", block group ", as.numeric(substr(GEOID, 12, 12))),
                               substr(GEOID, 3, 5) == "139" ~ paste0("Scott County tract ", as.numeric(substr(GEOID, 6, 11))/100, ", block group ", as.numeric(substr(GEOID, 12, 12))),
                               substr(GEOID, 3, 5) == "163" ~ paste0("Washington County tract ", as.numeric(substr(GEOID, 6, 11))/100, ", block group ", as.numeric(substr(GEOID, 12, 12))),
                               TRUE ~ NA_character_)) 

# usethis::use_data(mn_bgs, overwrite = TRUE)
filter(mn_bgs_raw, GEOID == "270539800001") #for na people blocks priority summary is giving two results; should only be one
filter(priority_summary, GEOID == "270539800001")
filter(priority_summary, GEOID == "270030501071")

mncounties <- tigris::counties(state = "MN") %>%
  filter(COUNTYFP %in% c("003", "019", "037", "053", "123", "139", "163"))
metc_region <- mncounties %>% group_by(COUNTYFP) %>% summarise(geometry = sf::st_union(geometry)) %>%
  sf::st_simplify(dTolerance = 400) %>%
  sf::st_transform(4326)
usethis::use_data(metc_region, overwrite = TRUE)

```

# Simplify data for speed

```{r}
speed_up <- function(x, smooth){
  x %>%
  sf::st_transform(26915) %>%
  sf::st_simplify(dTolerance = smooth, preserveTopology = T) %>%
  sf::st_transform(4326)
    
}
# nhood_list <- nhood_list %>% st_make_valid() %>% st_simplify(dTolerance = 100) %>% st_as_sf()
ctu_list <- ctu_list_raw %>%
  sf::st_transform(4326)
usethis::use_data(ctu_list, overwrite = TRUE)

nhood_list <- nhood_list_raw %>% 
  speed_up(50)
usethis::use_data(nhood_list, overwrite = TRUE)

redline <- redline_raw %>% 
  speed_up(50)
usethis::use_data(redline, overwrite = TRUE)

# lakes <- river_lake_all %>%
#   filter(SYSTEM %in% c("Lake"),
#          AREA_ACRES > 10) %>% #these rivers are boundaries
#   sf::st_transform(26915) %>%
#   st_union() %>%
#   st_buffer(-10) %>%
#   # smoothr::smooth(method = "ksmooth") %>%
#   sf::st_simplify(dTolerance = 50, preserveTopology = F) #There’s also a parameter preserveTopology which, when set to TRUE, makes sure that polygons are not reduced to lines or even removed, or that inner holes in them are removed during the simplification process.

# temp <- tempfile()
# download.file("https://resources.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_dot/trans_airports/gpkg_trans_airports.zip", destfile = temp)
# airports <- sf::read_sf(unzip(temp, "trans_airports.gpkg"))  %>%
#   st_buffer(dist = .$RUNWAY_WID) %>%
#   st_union() %>%
#   # ggplot() + geom_sf()
#   # sf::st_simplify(dTolerance = 25, preserveTopology = F) %>%
#   sf::st_transform(4326) 
  

mn_bgs <- mn_bgs_raw %>% 
  # if I want to remove lakes; I don't love them removed tbh
  # st_transform(26915) %>%
  # st_erase(lakes) %>% 
  # st_erase(airports) %>%
  sf::st_simplify(dTolerance = 25, preserveTopology = T) %>%
  sf::st_transform(4326) %>%
  filter(!is.na(GEOID)) #%>%
  # filter(GEOID != "270539800001") #remove airport
usethis::use_data(mn_bgs, overwrite = TRUE)


# leaflet::leaflet() %>%
#   leaflet::addPolygons(data = mn_bgs) %>%
#   leaflet::addPolygons(data = mn_bgs5, color = "red")
# object.size(mn_bgs) / 1e5
# object.size(mn_bgs5) / 1e5

bg_growingshade_main <- bg_growingshade_main %>%
  dplyr::select(bg_string, name, weights_scaled, raw_value) %>%
  filter(!is.na(bg_string))
usethis::use_data(bg_growingshade_main, overwrite = TRUE)

# eab <- eab %>% dplyr::select(geometry)
# usethis::use_data(eab, overwrite = TRUE)

# object.size(eab2) / 1e5
# object.size(eab) / 1e5
# # ggplot() +
# #   geom_sf(data = ctu_list) +
# #   geom_sf(data = ctu_list2, col = "blue", fill = NA)

```

# block group issues

the current watermask in gee is only for metcouncil area; this dataset probably works for rest of state: <https://gisdata.mn.gov/dataset/water-national-hydrography-data> (but need something from WI in there too)

would want to focus only on residential area or city boundaries; ag land has different purposes/uses/challenges/sustainability goals.

very slow when showing block groups across entire state

-- options: focus on statistical areas; some of this won't be super useful either since ag land focus on areas where population density is above some threshold
