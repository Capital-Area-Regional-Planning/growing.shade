---
title: "Growing Shade methods"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  github_document:
    toc: true
always_allow_html: true
urlcolor: blue
---

# Introduction

Growing Shade is a prioritization tool for tree canopy enhancement and preservation. Growing Shade was conceptualized by the Metropolitan Council, Tree Trust, and The Nature Conservancy with a focus on the Twin Cities (Minnesota) area. All analyses and code were developed by Ellen Esch. The Twin Cities version of Growing Shade can  be accessed at: www.growingshade.com or https://metrotransitmn.shinyapps.io/growing-shade/. 

The components of Growing Shade relevant to population demographics (i.e., determining environmental justice priority areas) can be scaled to any area within the United States. The components relevant to the tree canopy have been parameterized to the Twin Cities region, but should work pretty well in other temperate areas with deciduous and coniferous trees.

This tutorial walks through how to grab and synthesize various data pieces which go into making Growing Shade. This document should be useful when doing data updates update, or trying to scale this workflow to other regions/areas.

The first time you run this code, it will be helpful to walk step-by-step through the various pieces. There are several places where you'll get instructions to request and save API keys, or other manual steps which can't be automated. However, after you walk thorough it initially, in future runs (if needed) or for small data/geography adjustments, you can probably be successful running everything in one go!

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message = F, warning = F,
                      cache = F)
library(dplyr); library(tidyr); library(readr); library(stringr); library(tibble); library(ggplot2)
library(tigris)
library(sf)
library(tidycensus)
library(ggbeeswarm)
library(RSocrata)
library(here)


st_erase = function(x, y) st_difference(x, st_union(st_combine(y)))
`%not_in%` <- Negate(`%in%`)
```

# Set parameters

These global parameters dictate what state/county combinations will be used, as well as from what year various data pieces come from. Since the data pieces are updated on different schedules, it's unfortunately not as simple as setting a "global" rule to use data corresponding to the current year

This code is set up to use/process 2020-era census geographies at the block group level (even though some data sources are still using 2010-era geographies...but we'll deal with those later).

```{r set-parameters}
#####
# Geography variables
####
state <- c("MN")
county <- c("Anoka", "Carver", "Dakota", "Hennepin", "Ramsey", "Scott", "Washington") # either type in specific county names, or for all counties within a state assign `county <- NULL`

process_geographies <- TRUE 

#######
# Demographic variables
######
acs_year <- 2020 #The 2017-2021 ACS 5-year estimates are scheduled to be released on December 8, 2022. So this can be updated with "2021" then. 
census_year <- 2020

process_demographics <- FALSE
detailed_population_count <- FALSE #are there more accurate counts of total population and housing units available (for calculating density)? If so, bring those in

```

# Process demographic data

The demographic information is fetched using the APIs/app tokens. Follow these instructions:

You will need an API key from Census:

-   [Request an api key](https://api.census.gov/data/key_signup.html)
-   Enter in the console: `usethis::edit_r_environ()`
-   When the `.Renviron` file comes up in the editor, type: `CENSUS_KEY="KEY GOES HERE, INSIDE QUOTES"`
-   Save and close the `.Renviron` file.
-   Restart R.

You will need an app token from CDC:

-   [Request an app token](https://chronicdata.cdc.gov/profile/edit/developer_settings)
-   You may have to create an account with Tyler Data & Insights ID
    -   More information about "app tokens" and metadata are on the [PLACES data overview](https://dev.socrata.com/foundry/chronicdata.cdc.gov/cwsq-ngmh)
    -   Note that CDC has APIs and app tokens. It's a bit confusing, but be sure you are looking at the app token for this.
-   Enter in the console: `usethis::edit_r_environ()`
-   When the `.Renviron` file comes up in the editor, type: - `CDC_KEY="APP TOKEN GOES HERE, INSIDE QUOTES"` - `CDC_EMAIL="email you signed up with goes here, inside quotes"`
-   `CDC_PASSWORD="password you used to signup with goes here, inside quotes"`
-   Save and close the `.Renviron` file.
-   Restart R.

## Decennial census

Race variables come from the decennial 2020 census. Currently, the decennial census data is preferred over ACS data because it is a population count rather than a sample and because ACS data uses the average of 5 years (so starting with the ACS 2021-2025 data, it may be logical to switch over to using the ACS data instead).

```{r decennial}
if (process_demographics == TRUE) {
  
  
  if(detailed_population_count == TRUE){
    temp <- tempfile()
    temp2 <- tempfile()
    download.file(
      "https://resources.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_metc/society_small_area_estimates/xlsx_society_small_area_estimates.zip",
      destfile = temp)
    unzip(zipfile = temp, exdir = temp2)
    list.files(temp2)
    
    pop_count <- readxl::read_xlsx(paste0(temp2, pattern = "/SmallAreaEstimatesBlockGroup.xlsx")) %>%
      rename(population_count = mc_poptot,
             housing_units = mc_hutot)
    files <- list.files(temp2, full.names = T)
    file.remove(files)
  }
  
census_api_key(Sys.getenv("CENSUS_KEY"))

  # v2020 <- load_variables(census_year, "pl", cache = TRUE)
  # View(v2020)# %>% filter(geography == "block group"))
  
  
  decennial_var <- c(
    "P2_005N", # white nh
    "P2_006N", # black nh
    "P2_007N", # amin nh
    "P2_008N", # asian nh
    "P2_009N", # hawaiian pi nh
    "P2_010N", # some other nh
    "P2_011N", # 2+ nh
    "P2_002N", # hispanic
    
    "H1_001N" #total housing units
  )

  decennial_data <- get_decennial(
      geography = "block group",
      variables = decennial_var, 
      summary_var = "P1_001N",
      year = census_year,
      state = state,
      county = county,
      geometry = F
    ) %>%
      pivot_wider(names_from = variable, values_from = value) %>%
    
    #process data
    mutate(across(starts_with("P2"), ~ .x / summary_value)) %>%
    rename(whitenh = P2_005N,
        pblacknh = P2_006N,
        pamindnh = P2_007N,
        phisppop = P2_002N,
        housing_units = H1_001N) %>%
    mutate(pothmultnh = (P2_010N + P2_011N),
           pasiannh = (P2_008N + P2_009N),
           pbipoc = 1 - whitenh,
           population_count = summary_value) %>%
    select(-c(starts_with("P2"), summary_value)) %>%
    
    #get a nice name for tracts
    separate(NAME, into = c("bg", "tract", "county", "state"), sep = ",") %>%
    mutate(fancyname = paste0(county, " tract ", str_remove(tract, "Census Tract "), ", block group ", str_remove(bg, "Block Group "))) %>%
    select(-bg, -tract, -county, -state)
  
  
    decennial_metadata <- get_decennial(
      geography = "county",
      variables = decennial_var, 
      summary_var = "P1_001N",
      year = census_year,
      state = state,
      county = county,
      geometry = F
    )  %>%
        add_column(geo = "region averages") %>%
        group_by(geo, variable) %>%
        summarise(value = sum(value),
                  summary_value = sum(summary_value)) %>%
        pivot_wider(names_from = variable, values_from = value) %>%
    
    mutate(across(starts_with("P2"), ~ .x / summary_value)) %>%
    rename(whitenh = P2_005N,
        pblacknh = P2_006N,
        pamindnh = P2_007N,
        phisppop = P2_002N,
        housing_units = H1_001N) %>%
    mutate(pothmultnh = (P2_010N + P2_011N),
           pasiannh = (P2_008N + P2_009N),
           pbipoc = 1 - whitenh,
           population_count = summary_value) %>%
    select(-c(starts_with("P2"), summary_value, geo))
  
  save(decennial_data, decennial_metadata, file = paste0(here::here(), "/data-raw/decennial_data.rda"))
} else {
  load(paste0(here::here(), "/data-raw/decennial_data.rda"))
}
```

## American Community Survey

Other demographic variables come from the American Community Survey 5-year data. ACS numbers come from a surveyed population sample.

Check what is the most [recent year of ACS data here](https://api.census.gov/data.html). Search for "acs5" and see what is the most recent year of data available.

```{r acs}
if (process_demographics == TRUE) {
  census_api_key(Sys.getenv("CENSUS_KEY"))

  v20 <- load_variables(acs_year, "acs5", cache = TRUE)
  View(v20 %>% filter(geography == "tract"))
  View(v20 %>% filter(geography == "block group"))
  #  you may need to access the table shells: https://www.census.gov/programs-surveys/acs/technical-documentation/table-shells.html
  #  census reporter topics are also very useful! https://censusreporter.org/topics/

  acs_variables <- c(
    "B01001_001", #poptotal
    paste0("B01001_00", c(3:6)), #under18 m
    paste0("B01001_0", c(27:30)), #under18 f
    paste0("B01001_0", c(20:25, 44:49)), #over 65m, f
    "B19013_001",# median hh income
    "B25003_001", #tenure_total
    "B25003_002", #tenure owners
    "B23025_001", #employment status denominator
    "B23025_007", #unemployed
    paste0("C17002_00", c(1:6)) #poverty status
    )
  
 acs_fxn <- function(.geo, .process = NULL, .extra_vars = NULL){
   step1 <- get_acs(
    geography = .geo,
    variables = if(is.null(.extra_vars)) {acs_variables} else {.extra_vars},#c(acs_variables, .extra_vars),
    survey = "acs5",
      state = state,
      county = county,
    year = acs_year
  ) %>%
   select(-moe, -NAME) %>%
   pivot_wider(names_from = variable, values_from = estimate)  
   
   #process to useable forms of the data
   if(is.null(.process)) {
     step2 <- step1 %>%
     mutate(
     under18 = rowSums(across(c(
       paste0("B01001_00", c(3:6)), #under18 m
       paste0("B01001_0", c(27:30)) #under18 f
       ), na.rm = T)),
     over65 = rowSums(across(c(
       paste0("B01001_0", c(20:25, 44:49)) #over 65m, f
     ), na.rm = T))) %>%
   mutate(across(c(under18, over65), ~.x / B01001_001),  #, .names = "{.col}_percent"),
          sens_age = under18 + over65,
          pownhome = B25003_002 / B25003_001,
          pwk_nowork = B23025_007 / B23025_001,
          ppov185 = (C17002_002 + C17002_003 + C17002_004 + C17002_005 + C17002_006) / C17002_001) %>%
   rename(hhincome = B19013_001) %>%
   select(c(GEOID, !starts_with(c("B", "C"))))
   }
   
   if(is.null(.process)) {return (step2)} else {return (step1)}
 }
 
 acs_blockgroups <- acs_fxn(.geo = "block group") %>%
   mutate(tract_id = substr(GEOID, start = 1, stop = 11))
 
 acs_disability <- acs_fxn(.geo = "tract",
                           .process = "dont complete",
                           .extra_vars = c(paste0("C18108_0", c("01", "05", "09", "13")))) %>%
   mutate(nodisability = rowSums(across(c(paste0("C18108_0", c("05", "09", "13")))))) %>%
     transmute(tract_id = GEOID,
               pd_any = 1 - (nodisability / C18108_001))
 
 acs_tracts <- acs_fxn(.geo = "tract") %>%
                       # .extra_variables = (paste0("C18108_0", c("01", "05", "09", "13"))))# %>% #disability status; only exists at tract level
   mutate(across(c(hhincome:ppov185), ~.x, .names = "tr_{.col}")) %>%
   rename(tract_id = GEOID) %>%
   select(starts_with("tr")) %>%
   full_join(acs_disability)
 
 ### 
 # also want to get regional averages for metadata
 ###
 acs_metadata <- get_acs(
    geography = "county",
    variables = c(acs_variables, paste0("C18108_0", c("01", "05", "09", "13"))),
    survey = "acs5",
      state = state,
      county = county,
    year = acs_year
  ) %>%
   add_column(geo = "region averages") %>%
   group_by(geo, variable) %>%
   summarise(estimate = sum(estimate)) %>%
   pivot_wider(names_from = variable, values_from = estimate) %>%
   
   #process to useable forms of the data
   mutate(
     under18 = rowSums(across(c(
       paste0("B01001_00", c(3:6)), #under18 m
       paste0("B01001_0", c(27:30)) #under18 f
       ), na.rm = T)),
     over65 = rowSums(across(c(
       paste0("B01001_0", c(20:25, 44:49)) #over 65m, f
     ), na.rm = T)),
     nodisability = rowSums(across(c(paste0("C18108_0", c("05", "09", "13")))))) %>%
   mutate(across(c(under18, over65), ~.x / B01001_001),  #, .names = "{.col}_percent"),
          sens_age = under18 + over65,
          pownhome = B25003_002 / B25003_001,
          pwk_nowork = B23025_007 / B23025_001,
          ppov185 = (C17002_002 + C17002_003 + C17002_004 + C17002_005 + C17002_006) / C17002_001,
          pd_any = 1 - (nodisability / C18108_001)) %>%
   rename(hhincome = B19013_001) %>% 
   select(c(geo, !starts_with(c("B", "C")), -nodisability))
 
 ###
 # save files
 ###
 
  save(acs_blockgroups, acs_tracts, acs_metadata, file = paste0(here::here(), "/data-raw/acs_data.rda"))
} else {
  load(paste0(here::here(), "/data-raw/acs_data.rda"))
}
 
```

## PLACES health data

Health metrics come from [PLACES: Local Data for Better Health, Census Tract Data](https://chronicdata.cdc.gov/500-Cities-Places/PLACES-Local-Data-for-Better-Health-Census-Tract-D/cwsq-ngmh). I am not aware that there is a way to use a "health_year" parameter to get a specific timestamp of the data, so please just double check that the most recent data is being used! CDC has indicated that they *might* soon be switching over to using 2020-vintage census geographies rather than the old 2010 geographies, so the processing will get simplified at that point.

Also, because this CDC data currently uses old census geographies, you will need to download a crosswalk - Download the state-specific crosswalk of ["Block Groups --\> Census Tracts" for year "2010 --\> 2020" from NHGIS](https://www.nhgis.org/geographic-crosswalks#download-from-block-groups) - Place the resultant file in the data-raw folder

```{r health}
##########
# CDC health data
#########
# variable options are documented here: https://www.cdc.gov/places/measure-definitions/index.html

if (process_demographics == TRUE) {

raw_health <- read.socrata(
  # "https://chronicdata.cdc.gov/resource/cwsq-ngmh.json?$where=stateabbr in('MN', 'WI')",
 paste0("https://chronicdata.cdc.gov/resource/cwsq-ngmh.json?$where=stateabbr in('", state, "')"),
  app_token = Sys.getenv("CDC_KEY"), 
  email     = Sys.getenv("CDC_EMAIL"), 
  password  = Sys.getenv("CDC_PASSWORD")) %>%

  #get the columns of interest. there are more variables as an fyi though!
# names(bg_health)
# levels(as.factor(bg_health$measure))
  filter(measure %in% c("Current asthma among adults aged >=18 years",
                        "Chronic obstructive pulmonary disease among adults aged >=18 years",
                        "Mental health not good for >=14 days among adults aged >=18 years",
                        "Physical health not good for >=14 days among adults aged >=18 years")) %>%
  dplyr::select(locationname, measureid, data_value) %>%
  mutate(data_value = as.numeric(data_value) / 100) %>% #change to fraction
  pivot_wider(names_from = measureid, values_from = data_value)

fips <- tigris::lookup_code(state = state) %>%
  stringr::str_split("'", simplify = T)

crosswalk <- read_csv(paste0(here::here(), "/data-raw/nhgis_bg2020_tr2010_", fips[,2], ".csv"),
                      col_types = c('tr2010ge' = 'c',
                                    "bg2020ge" = "c")) %>%
  select(tr2010ge,#census geoid for 2010
         bg2020ge,#census geoid for 2020
         wt_pop) %>% #use weighted population crosswalk
  group_by(bg2020ge) %>%
  slice(which.max(wt_pop)) %>% # just get the crosswalk for where most people live. it's oversimplified, but pretty decent esp since block groups generally nest nicely into tracts across census geographies
  select(-wt_pop)


## translate health data into 2020 geographies
health_data <- raw_health %>%
  full_join(crosswalk, by = c("locationname" = "tr2010ge")) %>%
  rename(GEOID = bg2020ge) %>%
  select(-locationname)

  save(file = paste0(here::here(), "/data-raw/health_data.rda"), health_data)
} else {
  load(paste0(here::here(), "/data-raw/health_data.rda"))
}

```

# Process geographies

Growing Shade is set up to have data at the block group, neighborhood, and city/township (ctu) levels.

### Census block groups

Getting these geography files is easy - just downloaded directly.

```{r census-geography}
bg_geo <- block_groups(state = state, 
                                    county = county,
                                    year = census_year) 

# sf::st_write(bg_geo, "/Users/escheh/Documents/GitHub/planting.shade/storymap-info/shapefiles/bg_geo.shp", append = FALSE)

```


### Neighborhoods and city levels

Since we're going to be making a map which shows census tracts, cities, or neighborhoods depending on the user input, a crosswalk needs to be made which relates block groups to the city and neighborhood levels.

This section doesn't seem to be easily scalable to other regions. As such, the code for this section will likely need to be customized, and processing will be done within the `02_geographies.Rmd` script. Further, if this section doesn't apply for other regions, it should be easy enough to remove elements in the user-interface of the application.


In any case, the following files should exist in the `data` folder (again, the `02_geographies.Rmd` script shows an example of creating these files for the Twin Cities region).

- **ctu_crosswalk** which assign every block group in the region into a core city. Column names should be as follows:
  - `GEO_NAME` (city name, e.g. "Minneapolis" or "Stillwater")
  - `bg_id` (block group id)
- **nhood_crosswalk** which assigns block group in the region into a neighborhood. Column names should be as follows:
  - `GEO_NAME` (neighborhood name, e.g. "Powderhorn" or "Downtown")
  - `city` (core city in which neighborhood lies, e.g. "Minneapolis")
  - `bg_id` (block group id)
- **wide_ctu_crosswalk** indicates which city(ies) each block group belongs to. Column names:
  - `bg_id` (block group id)
  - `jurisdiction` (city or cities which the block group belongs to - where applicable cities should be separated by a ", "; i.e. "St. Francis, Bethel")


```{r, child = c('02_geographies.Rmd'), include=F, eval=F}
```

```{r}
load(paste0(here::here(), "/data-raw/geography_data.rda"))
usethis::use_data(ctu_crosswalk, overwrite = TRUE)
usethis::use_data(nhood_crosswalk, overwrite = TRUE)
```

# Remote sensing data

This section *may* scale to other regions, but currently requires some initial processing steps done *outside* of R, and hence the code has been moved into the `02_remotesensing.Rmd` script. 

These are the resulting files which should exist:

- **bg_canopy** which has the tree canopy cover of every block group. Columns should be as follows:
  - `bg_id` (block group identifier)
  - `canopy_percent` (the percent tree canopy cover in the block group)
  - `avgcanopy` (the average block group tree canopy cover; note, for the best comparative value, this avgcanopy variable should *not* be the regional average tree canopy (which would require incorporating the fact that all block groups are not the same area))
- **ctu_list_raw** which has information about the tree canopy at the city level. Columns:
  - `GEO_NAME` (the name of the city/township)
  - `canopy_percent` (the percent tree canopy cover in the city)
  - `avgcanopy` (the average canopy cover of block groups within the city)
  - `min` (the canopy cover value from the block group with the lowest tree cover in the city)
  - `max` (the canopy cover value from the block group with the highest tree cover in the city)
  - `n_blockgroups` (the number of block groups which fall inside the city)
  - `geometry` (the spatial coordinates of the city polygon)
- **nhood_list_raw** which has information about the tree canopy at the neighborhood level. Columns:
  - `GEO_NAME` (the name of the neighborhood)
  - `city` (the city in which the neighborhood is located)
  - `canopy_percent` (the percent tree canopy cover in the neighborhood)
  - `avgcanopy` (the average canopy cover of block groups within the neighborhood)
  - `min` (the canopy cover value from the block group with the lowest tree cover in the neighborhood)
  - `max` (the canopy cover value from the block group with the highest tree cover in the neighborhood)
  - `n_blockgroups` (the number of block groups which fall inside the neighborhood)
  - `geometry` (the spatial coordinates of the neighborhood polygon)
- **bg_ndvi** which has information about the greenness (as measured via NDVI, or normalized difference vegetation index) of block groups
  - `bg_id` (block group identifier)
  - `ndvi_uncultivated` (average NDVI over uncultivated land)
  - `ndvi_land` (average NDVI over all land, including cropland)

# Environmental data


## Lifetime cancer risk from air toxins

The EPA's 2021 EJSCREEN data release can be downloaded automatically and filtered for the region of interest. Interestingly, the 2021 EJSCREEN data uses 2017 AirToxScreen data, even though there does appear to be a more recent, [2018 AirToxScreen file](https://www.epa.gov/AirToxScreen/2018-airtoxscreen-assessment-results) as of October 3, 2022. 

It is my recommendation to use the EJSCREEN data because the process can be automated, and then just [check back to see when this data gets updated for future years](https://gaftp.epa.gov/EJSCREEN). Hopefully the 2018 AirToxScreen data will be incorporated soon. 

Additionally, please note that the 2021 EJSCREEN data is using old (2010-vintage) Census geographies (at the tract level). Fortunately, the crosswalk downloaded to process the PLACES health data will additionally work here. 


```{r air-toxins}
if (process_demographics == TRUE) {

temp <- tempfile()
temp2 <- tempfile()
download.file(
  "https://gaftp.epa.gov/EJSCREEN/2021/EJSCREEN_2021_USPR_Tracts.csv.zip",
  destfile = temp
)
unzip(zipfile = temp, exdir = temp2)
list.files(temp2)

ejscreen <- read_csv(paste0(temp2, pattern = "/EJSCREEN_2021_USPR_Tracts.csv"),
                     col_select = c(ST_ABBREV, CANCER, ID)) %>%
  filter(ST_ABBREV == state)

# #ejscreen is still using 2010 geographies
# ejscreen %>% left_join(bg_geo %>%
#                          mutate(ID = substr(GEOID, start = 1, stop = 11))) %>%
#   st_as_sf() %>%
#   ggplot() +
#   geom_sf(aes(fill = CANCER))

files <- list.files(temp2, full.names = T)
file.remove(files)

## translate into 2020 geographies
cancer_data <- ejscreen %>%
  full_join(crosswalk, by = c("ID" = "tr2010ge")) %>%
  rename(bg_id = bg2020ge) %>%
  select(bg_id, CANCER) %>%
  mutate(CANCER = if_else(is.na(CANCER), min(CANCER, na.rm = T), CANCER)) %>% #don't let there be NAs, fill with the minimum value
  # filter(!is.na(bg_id)) %>%
  rename(env_cancer = CANCER)

  save(file = paste0(here::here(), "/data-raw/cancer_data.rda"), cancer_data)
} else {
  load(paste0(here::here(), "/data-raw/cancer_data.rda"))
}

```

## Climate vulnerability - temperature & flooding

This section relies on processing remote sensing data outside of R, and may require some specific processing to work for other regions. Here, the files created are as follow: 

- **env_data** Column names, as applicable, should be as follows:
  - `bg_id` (block group geo-identifier)
  - `avg_temp` (average land surface temperature during a heatwave)
  - `prim_flood` (amount of land susceptible to primary flooding)

```{r environmental-data}
env_data <- readxl::read_xlsx(paste0(here::here(), "/data-raw/CLIMATE_BG20.xlsx")) %>%
  transmute(bg_id = BG20,
            avg_temp = AVG_TEMP,
            prim_flood = PRIM_FLOOD)

```


# Other & geographic overlay files

This may not be relevant for other regions, but here is the code.

## Redlining

This data describes the amount of block groups which were redlined. 


```{r holc-percents}
holc_data <- readxl::read_xlsx(paste0(here::here(), "/data-raw/HOLC_BG20.xlsx")) %>%
  transmute(bg_id = BG20,
            holc_pred = HOLC_4_RED) %>%
  right_join(bg_geo %>% st_drop_geometry() %>% transmute(bg_id = GEOID)) %>%
  mutate(holc_pred = if_else(is.na(holc_pred), 0, holc_pred)) 
```

```{r holc-geography}
#Remove open water. "all non residential"

## holc  ---------------
# ftp://ftp.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_metc/plan_historic_holc_appraisal/gpkg_plan_historic_holc_appraisal.zip
temp <- tempfile()
download.file("ftp://ftp.gisdata.mn.gov/pub/gdrs/data/pub/us_mn_state_metc/plan_historic_holc_appraisal/gpkg_plan_historic_holc_appraisal.zip",
  destfile = temp
)

redline_raw <- sf::read_sf(unzip(temp, "plan_historic_holc_appraisal.gpkg")) %>%
  filter(HSG_SCALE == "Hazardous") %>% 
  sf::st_union() %>%
  sf::st_transform(4326)

fs::file_delete("plan_historic_holc_appraisal.gpkg")
```

## MPCA area of environmental justice concern

```{r mpca}
#nothing here yet; this seems to be out-of-date...but it could come from equity considerations data
```

# Combine all variables

Merge demographic and environmental data. 

```{r combinedata}
load(paste0(here::here(), "/data-raw/canopy_data.rda"))

bg_growingshade_data <- 
  
  # direct-fetching data; exists for all regions/scale-able
  acs_blockgroups %>% 
  full_join(decennial_data) %>%
  full_join(health_data) %>%
  full_join(cancer_data, by = c("GEOID" = "bg_id")) %>%
  full_join(bg_geo %>% st_drop_geometry() %>% transmute(GEOID = GEOID, land = ALAND)) %>%
  full_join(acs_tracts) %>% 
  # deal with some non-residential blocks and insufficient data; demographics specific data
      mutate(across(-c(GEOID, fancyname, tract_id, land, starts_with("tr"), population_count), ~ if_else(population_count == 0, NA_real_, .x)),
           under18 = if_else(is.nan(under18), tr_under18, under18),
           over65 = if_else(is.nan(over65), tr_over65, over65),
           sens_age = if_else(is.nan(sens_age), tr_sens_age, sens_age),
           pownhome = if_else(is.nan(pownhome), tr_sens_age, pownhome),
           ppov185 = if_else(is.nan(ppov185), tr_sens_age, ppov185),
           hhincome = if_else(is.na(hhincome) & population_count > 0, tr_hhincome, hhincome),
           pwk_nowork = if_else(is.na(pwk_nowork) & population_count > 0, tr_pwk_nowork, pwk_nowork)) %>%
  select(!starts_with("tr")) %>%
  filter(!is.na(fancyname)) %>%

  # tree canopy data; needs to be prepared separately for different regions
  full_join(bg_canopy, by = c("GEOID" = "bg_id")) %>% 
  full_join(bg_ndvi, by = c("GEOID" = "bg_id")) %>%
  
  # other data; may not apply for other regions
  full_join(env_data, by = c("GEOID" = "bg_id")) %>% #extreme heat, flood risk
  full_join(holc_data, by = c("GEOID" = "bg_id")) %>%  #redlining

  # start to process the data
  mutate(inverse_ndvi_uncultivated = ndvi_uncultivated,
         inverse_ndvi_land = ndvi_land,
         inverse_canopy = canopy_percent,
         pop_density = population_count / land * 4045.86,
         housing_density = housing_units / land * 4045.86) %>%
  rename(bg_string = GEOID)
  
```


Add the variable codes. 

```{r make-metadata}
code_metadata <- read_csv(paste0(here::here(), "/data-raw/metadata.csv"))
```

Standardize and re-scale variables so we can create equally weighted priority scores. Do *not* include spatial data at this point, it should be joined after summarizing to save computational time.

```{r standardize-rescale}

bg_growingshade_main <- bg_growingshade_data %>%
  pivot_longer(names_to = "variable", values_to = "raw_value", -c(bg_string, fancyname)) %>% #end the code after this line if you just want the reshaped data
  group_by(variable) %>%
  mutate(MEAN = mean(raw_value, na.rm = T),
         SD = sd(raw_value, na.rm = T),
         MIN = min(raw_value, na.rm = T),
         MAX = max(raw_value, na.rm = T),
         COUNT = as.numeric(sum(!is.na(raw_value))),
         z_score = (raw_value - MEAN)/SD) %>%
  
  full_join(code_metadata, by = 'variable') %>%
  
  #create nominal weights
  mutate(weights_nominal = case_when(interpret_high_value == "high_opportunity" ~ (raw_value - MIN) / (MAX - MIN) * 10,
                                     interpret_high_value == "low_opportunity" ~ 10 - (raw_value - MIN) / (MAX - MIN) * 10,
                                     TRUE ~ NA_real_)) %>%
  
  #Weights Standard Score
  mutate(weights_scaled = case_when(interpret_high_value == "high_opportunity" ~ pnorm(z_score) * 10,
                                    interpret_high_value == "low_opportunity" ~ (10 - pnorm(z_score) * 10),
                                    TRUE ~ NA_real_)) %>%
  
  #weights rank
  mutate(weights_rank = case_when(interpret_high_value == "high_opportunity" ~ min_rank(desc(weights_nominal)) / COUNT * 10,
                                  interpret_high_value == "low_opportunity" ~ min_rank(desc(weights_nominal)) / COUNT * 10,
                                  TRUE ~ NA_real_)) %>%
  
  # #rank
  mutate(overall_rank = case_when(interpret_high_value == "high_opportunity" ~ min_rank(desc(as.numeric(weights_nominal))),
                                  interpret_high_value == "low_opportunity" ~ min_rank(desc(as.numeric(weights_nominal))))) %>%
  #clean
  dplyr::select(-MEAN, -SD, -MIN, -MAX)  %>%
  full_join(wide_ctu_crosswalk, by = c("bg_string" = "bg_id")) %>%
  filter(!is.na(name)) #remove variables which are NOT in the metadata list

```

# Create independant files for export

## Regional averages

Create some regional averages. While the average values for the block groups are needed to create zscores, those averages are not the regional averages. Ex average median income of block groups might be 60,000 but the regional average might be lower if there are more people living in ares with lower income.


```{r}
demo_metadata <- acs_metadata %>%
  full_join(decennial_metadata) %>%
  pivot_longer(names_to = "variable", values_to = "MEANRAW2", -geo) 

md1 <- bg_growingshade_main %>% 
  group_by(variable) %>% 
  summarise(MEANRAW = mean(raw_value, na.rm = T),
            MEANSCALED = mean(weights_scaled, na.rm = T))

md_gee <- 
  tribble(~rgn, ~variable, ~MEANRAW2,
          "twin cities", "canopy_percent", ctu_list_raw$avgcanopy[1], 
          "twin cities", "inverse_canopy", ctu_list_raw$avgcanopy[1]
  )


metadata <- bg_growingshade_main %>%
  dplyr::group_by(type, name, variable, interpret_high_value, climate_change, environmental_justice, public_health, conservation) %>%
  dplyr::count() %>%
  dplyr::ungroup() %>%
  full_join(md1) %>%
  mutate(niceinterp = 
               case_when(interpret_high_value == "high_opportunity" ~ "Higher",
                         TRUE ~ "Lower"),
         nicer_interp = case_when(niceinterp == "Lower" ~ "Lower values = higher priority", 
                                  variable == "inverse_ndvi_uncultivated" ~ "Higher values = higher priority",
                                  variable == "inverse_ndvi_land" ~ "Higher values = higher priority",
                                  variable == "canopy_percent2" ~ "Higher values = higher priority",
                                  TRUE ~ "")) %>%
  full_join(demo_metadata %>%
              bind_rows(md_gee)) %>%
  mutate(MEANRAW = if_else(!is.na(MEANRAW2), MEANRAW2, MEANRAW)) %>%
  dplyr::select(-MEANRAW2, -rgn, -geo) %>%
  filter(!is.na(name))

usethis::use_data(metadata, overwrite = TRUE)

```


## Highest priority for each block group

For storymap and to make database.

```{r}
# highest_p <- function(x) {
#   test <- enquo(x)
#   
#    bg_growingshade_main %>%
#   filter(name %in% (metadata %>%
#                       filter(!!test == 1)))
# }


highest_p <- function(group_var) {
  selectedvars <- metadata %>%
    filter(!!enquo(group_var) == 1) %>%
    .[,2]
  bg_growingshade_main %>% 
    filter(name %in% selectedvars$name) %>%
      group_by(bg_string) %>%
      summarise(MEAN = mean(weights_scaled, na.rm = F)) #set to false so that public health or ej doesnt get calculated if it is a nonres area
}

priority_summary_1 <-highest_p(public_health) %>% rename(`Public health` = MEAN) %>%
  full_join(highest_p(conservation) %>% rename(Conservation = MEAN)) %>%
  full_join(highest_p(environmental_justice) %>% rename(`Environmental justice` = MEAN)) %>%
  full_join(highest_p(climate_change) %>% rename(`Climate change` = MEAN)) %>%
  pivot_longer(names_to = "preset", values_to = "score", -bg_string) 

priority_summary <- priority_summary_1 %>%
  group_by(bg_string) %>%
  summarise(score = max(score, na.rm = T)) %>%
  left_join(priority_summary_1) %>%
  rename(highest_priority = preset) %>%
  rename(GEOID = bg_string)

selectedvars <- metadata %>%
    filter(public_health == 1) %>%
    .[,2]
  bg_growingshade_main %>% 
    filter(name %in% selectedvars$name) %>%
      group_by(bg_string) %>%
      summarise(MEAN = mean(weights_scaled, na.rm = F)) 

```

# Export data

```{r bg_shapefiles_for_mapping}

mn_bgs_raw <- bg_geo %>%
  right_join(bg_growingshade_data %>% select(bg_string, fancyname), by = c("GEOID" = "bg_string")) %>%
  right_join(wide_ctu_crosswalk, by = c("GEOID" = "bg_id")) %>%
  full_join(bg_canopy, by = c("GEOID" = "bg_id")) %>%
  full_join(priority_summary) %>%
  full_join(priority_summary_1 %>%
              group_by(preset) %>% 
              pivot_wider(names_from = preset, values_from = score),
            by = c("GEOID" = "bg_string")) %>%
  mutate(avgcanopy = mean(canopy_percent, na.rm = T)) %>%
  dplyr::select(-c(STATEFP, COUNTYFP, TRACTCE, BLKGRPCE, NAMELSAD, MTFCC, FUNCSTAT, INTPTLAT, INTPTLON)) %>%
  sf::st_as_sf() %>%
      sf::st_transform(4326) %>% 
  filter(!is.na(highest_priority)) %>%
  rename(GEO_NAME = GEOID)

mncounties <- tigris::counties(state = state) %>%
  filter(NAME %in% county)
metc_region <- mncounties %>% group_by(COUNTYFP) %>% summarise(geometry = sf::st_union(geometry)) %>%
  sf::st_simplify(dTolerance = 400) %>%
  sf::st_transform(4326)
usethis::use_data(metc_region, overwrite = TRUE)


```

# Simplify data for speed

```{r}
speed_up <- function(x, smooth){
  x %>%
  sf::st_transform(26915) %>%
  sf::st_simplify(dTolerance = smooth, preserveTopology = T) %>%
  sf::st_transform(4326)
    
}
# nhood_list <- nhood_list %>% st_make_valid() %>% st_simplify(dTolerance = 100) %>% st_as_sf()
ctu_list <- ctu_list_raw %>%
  sf::st_transform(4326)
usethis::use_data(ctu_list, overwrite = TRUE)

nhood_list <- nhood_list_raw %>% 
  speed_up(50)
usethis::use_data(nhood_list, overwrite = TRUE)

redline <- redline_raw %>% 
  speed_up(50)
usethis::use_data(redline, overwrite = TRUE)

mn_bgs <- mn_bgs_raw %>% 
  sf::st_simplify(dTolerance = 25, preserveTopology = T) %>%
  sf::st_transform(4326) %>%
  filter(!is.na(GEO_NAME)) %>%
  mutate(GEOID = GEO_NAME)
usethis::use_data(mn_bgs, overwrite = TRUE)

object.size(mn_bgs_raw) / 1e5 ; object.size(mn_bgs) / 1e5

bg_growingshade_main <- bg_growingshade_main %>%
  dplyr::select(bg_string, name, weights_scaled, raw_value) %>%
  filter(!is.na(bg_string))
usethis::use_data(bg_growingshade_main, overwrite = TRUE)

```

# Running application

If the follow steps have been followed, you should be able to navigate to the `./dev/run_dev.R` file, select all the code, and run! This should initiate a local version of Growing Shade for the customized region! 

## Troubleshooting application

The "report" section is quite detailed, and various sections may not work if all the data isn't there. For instance, if there isn't data on NDVI, the figure relating how greenness (trees) contribute to lower land surface temperatures won't work. 


